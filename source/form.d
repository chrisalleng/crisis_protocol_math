import std.traits;
import std.base64;
import core.stdc.string : memcpy;

import vibe.d;

// Common enums
enum AttackPilot : ubyte
{
    None = 0,
    Backdraft,
    HortonSalm,
    Ibtisam,
    RearAdmiralChiraneau,
    Rey,
    SunnyBounder,
    PoeDameron,

    // TODO
    // NorraWexley
    // JessPava... weird and probably better to just do via advanced
    // BobaFettScum... weird like Jess
    // TarnMison... but only matters in some very contrived circumstances w/ gunner
    // HobbieKlivian
    // WesJanson... again would only matter w/ multi-attack which he can't get currently
    // LieutenantBlount... again very specific cases
    // HanSolo
    // EadenVrill... only because it depends on stress which could change for multi-attack
    // LieutenantKestal... logic could be complex, but probably just keep it opportunistic
    // ColonelVessery... easy enough to model for any reason scenarios by just giving him tokens
    // Wampa
    // WingedGundark    
    // KirKanos
    // SoontirFel
    // OmegaAce
    // OmegaLeader
    // KrassisTrelix... only secondaries
    // Imperial Kath Scarlet
    // Inaldra?
    // DreaRenthal
    // Bossk
    // KeyanFarlander
    // TenNumb

    // Aura abilities that probably don't belong in this enum
    // Howlrunner... also another ship ability
    // CarnorJax... also another ship
    // CaptainJonus... also affects friendlies instead
    // EtahnAbaht is weird since he affects other people's attacks...
}
enum DefensePilot : ubyte
{
    None = 0,
    EzraBridger,
    Ibtisam,
    LukeSkywalker,
    Rey,
    SabineWrenLancer,
    SunnyBounder,
    PoeDameron,

    // TODO
    // DarkCurse
    // Countdown
    // Inaldra?
    // LaetinAshera
    // ZebOrrelios

    // Aura abilities that don't belong in this enum
    // Serissu
}


// Handy utility from vibe.d
private template isPublicMember(T, string M)
{
    import std.algorithm, std.typetuple : TypeTuple;

    static if (!__traits(compiles, TypeTuple!(__traits(getMember, T, M)))) enum isPublicMember = false;
    else {
        alias MEM = TypeTuple!(__traits(getMember, T, M));
        static if (__traits(compiles, __traits(getProtection, MEM)))
            enum isPublicMember = __traits(getProtection, MEM).among("public", "export");
        else
            enum isPublicMember = true;
    }
}


public void update_form_fields(T)(const(FormFields) fields, ref T form)
{
    foreach (member; __traits(allMembers, T))
    {
        static if (isPublicMember!(T, member))
        {
            mixin("alias m = form." ~ member ~ ";");

            // Imperfect test, but good enough to weed out the right properties
            // Basically we're checking for the properties generated by the bitfield mixin
            static if (isSomeFunction!m && !hasStaticMember!(T, member))
            {
                static if (!is(ReturnType!m == void))
                    alias m_type = ReturnType!m;
                else
                    alias m_type = Parameters!m[0];
                
                // Should only have ints and bools in these structures for now
                static if (is(m_type == ubyte) || is(m_type == ushort) || is(m_type == uint) || is(m_type == byte) || is(m_type == int))
                {
                    mixin("form." ~ member ~ " = to!m_type(fields.get(\"" ~ member ~ "\", to!string(form." ~ member ~ ")));");
                }
                else static if (is(m_type == bool))
                {
                    // NOTE: Doesn't properly respect default true... need to figure out how to handle
                    // this since HTML forms don't submit anything for unchecked items
                    mixin("form." ~ member ~ " = fields.get(\"" ~ member ~ "\", \"\") == \"on\";");
                }
                else
                {
                    pragma(msg, member);
                    static assert (false);
                }
            }
        }
    }
}

public string serialize_form_to_url(T)(const(T) form)
{
    ubyte[T.sizeof] data;
    memcpy(data.ptr, &form, T.sizeof);
    return Base64URL.encode(data);
}

// NOTE: If url is empty, simply returns form defaults
public T create_form_from_url(T)(string url)
{
    T form = T.defaults();

    if (!url.empty)
    {
        // NOTE: Must handle cases where data size is less than basic form size
        // as users could be using an old link. Allow any new fields to just use defaults
        ubyte[] data = Base64URL.decode(url);    
        if (data.length > T.sizeof)
        {
            // Invalid - TODO: handle this better
            throw new HTTPStatusException(HTTPStatus.badRequest);
        }
        memcpy(&form, data.ptr, data.length);
    }

    return form;
}

public T create_form_from_fields(T)(const(FormFields) fields)
{
    T form = T.defaults();
    update_form_fields(fields, form);
    return form;
}
